<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			var tree={
				value:1,
				left:{
					value:2,
					left:{
						value:4
					}
				},
				right:{
					value:3,
					left:{
						value:5,
						left:{
							value:7
						},
						right:{
							value:8
						}
					},
					right:{
						value:6
					}
				}
			}
			
//			非递归后序(使用一个栈)
//			这里使用了一个临时变量记录上次入栈/出栈的节点。思路是先把根节点和左树推入栈，然后取出左树，再推入右树，取出，最后取跟节点。
			var postOrder=function(node){
				 if(!node) {
				    throw new Error('Empty Tree')
				  }
				  var stack = []
				  stack.push(node)
				  var tmp = null
				  while(stack.length !== 0) {
				    tmp = stack[stack.length - 1]
				    if(tmp.left && node !== tmp.left && node !== tmp.right) {
				      stack.push(tmp.left)
				    } else if(tmp.right && node !== tmp.right) {
				      stack.push(tmp.right)
				    } else {
				      console.log(stack.pop().value)
				      node = tmp
				    }
				  }
			}
			
			
//			非递归后序(使用两个栈)
//			这个算法的思路和上面那个差不多，s1有点像一个临时变量。
			var posOrderUnRecur = function(node) {
			  if(node) {
			    var s1 = []
			    var s2 = []
			    s1.push(node)
			    while(s1.length !== 0) {
			      node = s1.pop()
			      s2.push(node)
			      if(node.left) {
			        s1.push(node.left)
			      }
			      if(node.right) {
			        s1.push(node.right)
			      }
			    }
			    while(s2.length !== 0) {
			      console.log(s2.pop().value);
			    }
			  }
			}
			
			posOrderUnRecur(tree);
		</script>
	</body>
</html>
